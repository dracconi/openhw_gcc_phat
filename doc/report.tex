\documentclass[a4paper,twocolumn]{article}

\usepackage{amsmath}
\usepackage{amssymb}

\title{Accelerating the Generalized Cross Correlation through Vitis HLS}
\date{Summer 2025}

\author{
  Malina, Kacper
}

\begin{document}
\maketitle

\section{Introduction}

Algorithms that are used in the location of the source of
some traveling waves, such as sound or EM, usually involve splitting
the problem into two: first finding the delays between the same wave
arriving at different sensors, then using mathematical transformations
to calculate (or guess) the position of the source based on those
delays\cite{tdoamlat}. This project is concerned with accelerating the
first step, that is finding the delays, or time differences of
arrivals, TDOA for short.

One of the methods (and a pretty common one) is the Generalized Cross
Correlation, hereafter called GCC\cite{gccphat}. The specific method
that will be considered here is called GCC-PHAT, where PHAT means
Phase Transform. It is a type of normalization applied in the
calculation. The IP core described here could easily be adapted for
other, similar, types of normalization, or it could be turned off
completely.

This paper focuses on the implementation of GCC-PHAT on an FPGA. To
enable easy integration with other cores, all the interfaces used are
AXI4-Stream\cite{axis}, shortened to AXIS. To ease the prototyping, a
UART-AXIS bridge is also provided in the project.

\section{Method}

The core supports multiple channels (default 4) to yield multiple
delays (number of channels less 1). Each channel is has its delay
calculated w.r.t. the reference channel 0. It involves performing the
GCC 3 times, one for each non-reference channel.

Lets assume that there are $k$ channels $x_k$, and w.l.o.g. channel
$x_0$ is the reference channel. Fourier transform (FT) is
$\mathfrak F$ and inverse FT is $\mathfrak F^{-1}$. A channel is
fixed-length time-domain signal, with the default length being
1024 samples in the core. This is also denoted here with $\tau$.

Firstly, do FT on all channels
\[x_k \xrightarrow{\mathfrak F} X_k\]
Note that $X_k$ are complex signals.
Then the cross-correlation is performed
\[Y_k = X_k \cdot X_0^*, k > 0\]
Then the values are normalized (the -PHAT part)
\[Y_k' = Y_k / |Y_k|, k > 0\]
Lastly, perform inverse FT,
\[Y_k' \xrightarrow{\mathfrak F^{-1}} y_k', k > 0\]
The time coordinate $t_k$ of the maximum $\mathrm{max}(y_k'), k > 0$
is the delay between channels 0 (reference) and $k$.
Note that FT works on periodic signals, thus $t_k$ is periodic, with
period $\tau$, and $t_k = t_k + n\tau, n\in\mathbb{Z}$. More obvious
result of that is that, if $t_k > \tau / 2$, it means that $t_k$ might
actually be negative, with value $t_k = t_k - \tau$. This is how the
core handles it as well.

The Python script, which implements this directly, as a reference, is
provided in \texttt{/py/golden\_gcc.py} in the repository.

\section{Implementation}

For the implementation of that method, Vitis HLS was chosen, as it is
relatively easy and quick to get all the math operations synthesized.

The method has been directly translated from the above description
into C++. Please see \texttt{/hls\_gcc/gcc\_phat/gcc\_phat.cpp} for
more details. The sample width on the input was selected to be
fixed-point 16-bit, although it does get expanded in the calculations
to 32-bit fixed-point and 32-bit float. This is done to conserve the
BRAM used for storing the results in between. The output has been
selected as 16-bit signed integer, which fully contains the possible
output of GCC PHAT, given that the FFT Logicore IP\cite{xfft} allows a
maximum of $2^{16}$ for the FFT length.

The core is implemented with AXIS input and output streams and no
further control, that is this is a data-driven IP core. 

The reported latency, with the default settings, post-synthesis
in Vitis is 350 $\mu$s. The part selected for implementation is
XC7S50CSGA324-1, available on the RealDigital Urbana devboard.
This is a single-clock design, with the clock being 100MHz.

\begin{tabular}{r|l|l|l|l}
  Stage & BRAM & DSP & FF & LUT \\
  Vitis & 23 & 24 & 26.5k & 22.5k \\
  Synth. & 11.5 & 72 & 17k & 14k \\
  Impl. & 11.5 & 72 & 16.5k & 12.5k \\
  Use\% & 16\% & 60\% & 28\% & 42\%
\end{tabular}

Note that the values reported for Implementation include UART-AXIS
bridge and 2 Data Width converters, each of which reports around 40
LUT and 60 FF post-synthesis. The reported power is 422mW. Last row
\emph{Use\%}, reports the \% use w.r.t. total available resources on
the FPGA, post-implementation.

All the strategies and settings not mentioned above are set as
default. The design was connected with Block Design tool.

\section{UART-AXIS bridge}

To allow writing (and reading) data to (and from) the core, special
UART-AXIS bridge was prepared. The implementation is available in the
repository, with the filename \texttt{uart\_axis.v}. It directly
divides the 100MHz clock by 33 (on default) to get 3.03MHz and
allow for 3Mbaud UART communication. It is within 1\% of the required
frequency.

Since the specific use-case is that the UART communication takes place
on a short on-board trace, that is, between the FTDI chip on Urbana
and the FPGA chip, 3Mbaud communication works correctly. Due to that,
and the demo conditions, no checksum checking core has been devised
here. That is, in this configuration, all UART data is directly
injected into the AXIS interface, and vice-versa on the reading side.
There is no FIFOs implemented, and failure to read the data results in
its loss. However, since UART communication is \emph{much} slower
(300kB/s) than the FPGA and all the interfaces, this is unlikely to
happen here.

The USB part of the USB-UART FTDI chip unfortunately has latency that
does not allow for low-latency ping-pongs between the core and the
computer. It has not been implemented here, as this only serves as a
demo, but additional FIFOs would be required to actually stream data
through this interface. It works good enough for debugging and demo
purposes, though.

\section{Results}



\section{Conclusions}


\begin{thebibliography}{9}
\bibitem{gccphat}
  Knapp, C. H. and Carter, G.C., \emph{The Generalized Correlation
  Method for Estimation of Time Delay.} IEEE Transactions on Acoustics,
  Speech and Signal Processing

\bibitem{tdoamlat}
  Schau, H. and Robinson, A., \emph{Passive source localization
  employing intersecting spherical surfaces from\\
  time-of-arrival differences} IEEE Transactions on Acoustics, Speech, and Signal
  Processing

\bibitem{urbana}
  RealDigital \emph{Urbana: Reference and Schematic}

\bibitem{vitis}
  AMD \emph{Vitis High-Level Synthesis User Guide} UG1399

\bibitem{xfft}
  AMD \emph{Fast Fourier Transform LogiCORE IP Product Guide} PG109

\bibitem{vivado}
  AMD \emph{Vivado Design Suite Tcl Command Reference Guide} UG835

\bibitem{axis}
  ARM \emph{AMBA AXI-Stream Protocol Specification}
  
\end{thebibliography}

\end{document}
